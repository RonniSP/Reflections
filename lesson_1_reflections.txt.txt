Reflextion steps of the GitHub course.

Lesson 1

How did viewing a diff between two versions of a file help you see the bug that was introduced?

Being able to compare two files this way makes it significantly easier to find any unwanted changes that
could have been made to a piece of code whilst producing it, as this task is reduced to only comparing
code that have been changed instead of the whole code.


How could having easy access to the entire history of a file make you a more efficient programmer in the long term?

Should you make an error and overwrite the old functioning version without having a backup file you will have to go
 through the entire set of changes made in your file since the last functioning version you remember by heart. Worst
 case you need to go through practically every line of code. Having automatically backed up versions of your code
 will allow you to use the previous described comparison function to quickly find the culprit of the error.


What do you think are the pros and cons of manually choosing when to create a commit, like you do in Git,
vs having versions automatically saved, like Google Docs does?

Manually choosing when to create a commit allows every commit to have a useful and defined addition to the
file. The problem is, that if you spend too much time figuring out how to create the addition, you risk
the chance of losing your changes should anything happen. This will not occur with automated saving.


Why do you think some version control systems, like Git, allow saving multiple files in one commit,
while others, like Google Docs, treat each file separately?

Being able to see which files were modified at the same time makes a lot of sense when writing code,
as you often make changes to files that are connected. This especially holds true since you want to
keep files small so that you can reuse a given function in a new set of codes.


How can you use the commands git log and git diff to view the history of files?

You can find the different versions of a given file with the got log command and then use git diff to
 see what changes were made by comparing a version of the file with the previous version.


How might using version control make you more confident to make changes that could break something?

If you know that you can always access the previous version of the file you are working on with little effort, you
will not be afraid of creating bigger modifications that would otherwise take a lot of work to revert should they not work.


Now that you have your workspace set up, what do you want to try using Git for?

First I want to try and download files from Github (including other courses at Udacity :P) Also, I want to try for my
 next programming project to use github as a backup template.

Lesson 2

 What happens when you initialize a repository? Why do you need to do it?

 You will be able to make commits of the files in the folder of the repository, efficiently backing up the files in the
 folder, allowing you to revert any changes you make.


 How is the staging area different from the working directory and the repository? What value do you think it offers?

 The staging area is a temporary “conceptual location”, whereas both the directory and the repository are “real locations”.
 The value of the staging area is, that you can have a good overview of what changes you are about to make to the two others,
 before you choose to do so.


 How can you use the staging area to make sure you have one commit per logical change?

 By using the command ‘git diff --staged’ you can see exactly what changes that are present in the staging area files compared
  to the newest commit in the repository.
 By using the command ‘git status’ you can see the changes that have been added from the work space to the staging area before
 using commit.


 What are some situations when branches would be helpful in keeping your history organized? How would branches help?

 If you want to have different parallel versions containing modifications of some parameters within the files, then it makes
sense to have branches. This would also make sense to do as a intermediate step to work on i.e. introducing something like a
different difficulty degree of a game and only add it when it is functional.


How do the diagrams help you visualize the branch structure?

It shows how many commits were made after the branching out occurred and thus how the newest version of the different branches
are connected.


What is the result of merging two branches together? Why do we represent it in the diagram the way we do?

When merging two branches together we keep all the modifications made within the two branches in the new final merged version.


What are the pros and cons of Git’s automatic merging vs. always doing merges manually?

The automated merging allows for a faster work process when there are no conflicts in the two pieces of code being merged. If
git does not see a conflict you know that you are good to continue as there will be no modifications hitting the same piece
of code (note though, that modifications that can clash can be put in separately of each other still). When git does see a
conflict, you will want to check it out manually, in order to see if and how big a potential conflict is.


Lesson 3
